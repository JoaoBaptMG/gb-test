;
; player.z80
; Routines to control the player
;

include "gameboy.inc"
include "util/structs.inc"

BBoxWidth equ 16*256
BBoxHeight equ 32*256

; Reserve data for the player
section "wram player.z80", wram0
; player's X as a 16.8 fixed point
wPlayerX: ds 3
; player's Y as a 16.8 fixed point
wPlayerY: ds 3 
; player's speed-X as an 8.8 fixed point
wPlayerSpdX: ds 2
; player's speed-Y as an 8.8 fixed point
wPlayerSpdY: ds 2
; player's animation frame
wPlayerAnimStep: db
; camera offset X as a 16-bit integer
wCameraOffsetX:: dw
; camera offset Y as a 16-bit integer
wCameraOffsetY:: dw

section "bank 0 player.z80", rom0
; Load's the player's character on screen
PlayerLoadData::
    ; Copy the character's graphics
    ld hl, vSpriteData
    ld de, data_sprites_player_png
    ld bc, data_sprites_player_png_end - data_sprites_player_png
    jp MemoryCopy

; Init the player's "singleton object"
PlayerInit::
    ; Initialize the player
    SetDataFixed168 wPlayerX, 11*16 + 0, 0
    SetDataFixed168 wPlayerY, 12*16 + 0, 0
    SetData8 wPlayerAnimStep, 0
    ret

; Update the player, pushing the OAM alongside it
PlayerUpdate::
    ; Zero the speed data
    ld hl, wPlayerSpdX
    xor a
    ld [hl+], a
    ld [hl+], a
    ld [hl+], a
    ld [hl+], a

    ; Get the speed modifier
    ldh a, [hJoypadPress]
    bit PADB_A, a
    jr z, .normalSpeed

    ld b, 5
    ld c, -5
    jr .getLeftRight

.normalSpeed:
    ld b, 1
    ld c, -1

.getLeftRight:
    ; Get joypad input
    ldh a, [hJoypadPress]
    bit PADB_LEFT, a
    jr nz, .moveLeft
    bit PADB_RIGHT, a
    jr z, .moveYDirection

.moveRight:
    ld a, b
    ld [wPlayerSpdX+1], a
    jr .moveYDirection

.moveLeft:
    ld a, c
    ld [wPlayerSpdX+1], a

.moveYDirection:
    ld a, [hJoypadPress]
    bit PADB_UP, a
    jr nz, .moveUp
    bit PADB_DOWN, a
    jr z, .updatePosition

.moveDown:
    ld a, b
    ld [wPlayerSpdY+1], a
    jr .updatePosition

.moveUp:
    ld a, c
    ld [wPlayerSpdY+1], a

.updatePosition:
    ; Add the Y-velocity to the Y-position
    ld hl, wPlayerSpdY
    ld a, [hl+]
    ld b, [hl]
    ld hl, wPlayerY
    add a, [hl]
    ld [hl+], a
    ld a, [hl]
    adc a, b
    ld [hl+], a

    ; Special check for addition carry (manual 2-complement)
    ; For each of the cases: no carry & b.7 = 0 | carry & b.7 = 0  | no carry & b.7 = 1 | carry & b.7 = 1  |
    sbc a, a               ; a = 0              | a = -1           | a = 0              | a = -1           |
    rl b                   ; carry = 0          | carry = 0        | carry = 1          | carry = 1        |
    jr nc, .collisionMovingDown

    ; Here, the Y speed is negative
    ld b, a                ; b = 0              | b = -1           | b = 0              | b = -1           |
    ld a, [hl]             ; a = [hl], b = 0    | a = [hl], b = -1 | a = [hl], b = 0    | a = [hl], b = -1 |
    sbc a, b               ; a = [hl]           | a = [hl]+1       | a = [hl]-1         | a = [hl]         |
    ld [hl], a             ; expected behavior in all cases

    ; Check for vertical collision
    ld hl, wPlayerX
    ld bc, BBoxWidth - 1                ; the width of the bbox minus $0.01
    ld de, 0                            ; zero, since the speed is negative
    call CheckHorizontalLineCollision

    ; If no collision, skip this step
    jr nc, .updateX

    ; Clamp the player to a tile boundary
    ld hl, wPlayerY
    xor a
    ld [hl+], a         ; Zero subpixels
    ld a, [hl]          ; Add 1 tile
    and a, $F0
    add a, 16
    ld [hl+], a
    jr nc, .updateX     ; Update the high byte if necessary
    inc [hl]
    jr .updateX

.collisionMovingDown:
    ; Here, the Y speed is positive
    ld b, a                ; b = 0              | b = -1           | b = 0              | b = -1           |
    ld a, [hl]             ; a = [hl], b = 0    | a = [hl], b = -1 | a = [hl], b = 0    | a = [hl], b = -1 |
    sbc a, b               ; a = [hl]           | a = [hl]+1       | a = [hl]-1         | a = [hl]         |
    ld [hl], a             ; expected behavior in all cases

    ; Check for vertical collision
    ld hl, wPlayerX
    ld bc, BBoxWidth - 1                ; the width of the bbox minus $0.01
    ld de, BBoxHeight                   ; we want to check the bottom row
    call CheckHorizontalLineCollision

    ; If no collision, skip this step
    jr nc, .updateX

    ; Clamp the player to a tile boundary
    ld hl, wPlayerY
    xor a
    ld [hl+], a         ; Zero subpixels
    ld a, [hl]
    and a, $F0
    ld [hl+], a

.updateX:
    ; Add the X-velocity to the X-position
    ld hl, wPlayerSpdX
    ld a, [hl+]
    ld b, [hl]
    ld hl, wPlayerX
    add a, [hl]
    ld [hl+], a
    ld a, [hl]
    adc a, b
    ld [hl+], a

    sbc a, a
    rl b
    jr nc, .collisionMovingRight

    ; Here, the X speed is negative
    ld b, a
    ld a, [hl]
    sbc a, b
    ld [hl], a

    ; Check for vertical collision
    ld hl, wPlayerX
    ld bc, BBoxHeight - 1                ; the height of the bbox minus $0.01
    ld de, 0                             ; zero, since the speed is negative
    call CheckVerticalLineCollision

    ; If no collision, skip this step
    jr nc, .updateCameraOffset

    ; Clamp the player to a tile boundary
    ld hl, wPlayerX
    xor a
    ld [hl+], a         ; Zero subpixels
    ld a, [hl]          ; Add 1 tile
    and a, $F0
    add a, 16
    ld [hl+], a
    jr nc, .updateCameraOffset     ; Update the high byte if necessary
    inc [hl]
    jr .updateCameraOffset

.collisionMovingRight:
    ; Here, the X speed is positive
    ld b, a
    ld a, [hl]
    sbc a, b
    ld [hl], a

    ; Check for vertical collision
    ld hl, wPlayerX
    ld bc, BBoxHeight - 1               ; the height of the bbox minus $0.01
    ld de, BBoxWidth                    ; we want to check the bottom row
    call CheckVerticalLineCollision

    ; If no collision, skip this step
    jr nc, .updateCameraOffset

    ; Clamp the player to a tile boundary
    ld hl, wPlayerX
    xor a
    ld [hl+], a         ; Zero subpixels
    ld a, [hl]
    and a, $F0
    ld [hl+], a

.updateCameraOffset:
    ; Update the camera offset
    ; In the X direction
    ld hl, wPlayerX+1
    ld a, [hl+]
    ld c, a
    ld b, [hl]

    ; Check if the pos is < 72
    ld a, b
    and a
    jr nz, .xPositive
    ld a, c
    cp a, 72
    jr nc, .xPositive

    ; Clamp camera offset to 0
    xor a
    ld hl, wCameraOffsetX
    ld [hl+], a
    ld [hl], a
    jr .checkY

.xPositive:
    ; Check if the pos is > than the maximum possible
    ld hl, wMaxCameraPositionRight+1
    ld a, [hl-]
    ld d, a
    cp a, b
    jr c, .setXRight        ; jump if hmax < b
    jr nz, .setXNormal      ; here, hmax >= b, jump if hmax != b
    ld a, [hl]
    cp a, c
    jr nc, .setXNormal      ; jump if lmax >= c

    ; here, either hmax < b or (hmax = b and lmax < c)
.setXRight:
    ; Clamp camera offset to (max position - 72)
    ld a, [hl]
    sub a, 72
    ld hl, wCameraOffsetX
    ld [hl+], a
    jr nc, .noOverflow3
    dec d
.noOverflow3:
    ld [hl], d
    jr .checkY

.setXNormal:
    ; Set camera offset to (player X - 72)
    ld a, c
    sub a, 72
    ld hl, wCameraOffsetX
    ld [hl+], a
    jr nc, .noOverflow0
    dec b
.noOverflow0:
    ld [hl], b

.checkY:
    ; In the Y direction
    ld hl, wPlayerY+1
    ld a, [hl+]
    ld c, a
    ld b, [hl]

    ; Check if the pos is < 48
    ld a, b
    and a
    jr nz, .yPositive
    ld a, c
    cp a, 48
    jr nc, .yPositive

    ; Clamp camera offset to 0
    xor a
    ld hl, wCameraOffsetY
    ld [hl+], a
    ld [hl], a
    jr .addSprite

.yPositive:
    ; Check if the pos is > than the maximum possible
    ld hl, wMaxCameraPositionBottom+1
    ld a, [hl-]
    ld d, a
    cp a, b
    jr c, .setYDown         ; jump if hmax < b
    jr nz, .setYNormal      ; here, hmax >= b, jump if hmax != b
    ld a, [hl]
    cp a, c
    jr nc, .setYNormal      ; jump if lmax >= c

    ; here, either hmax < b or (hmax = b and lmax < c)
.setYDown:
    ; Clamp camera offset to (max position - 48)
    ld b, a
    ld a, [hl]
    sub a, 48
    ld hl, wCameraOffsetY
    ld [hl+], a
    jr nc, .noOverflow4
    dec d
.noOverflow4:
    ld [hl], d
    jr .addSprite

.setYNormal:
    ; Set camera offset to (player Y - 48)
    ld hl, wCameraOffsetY
    ld a, c
    sub a, 48
    ld [hl+], a
    jr nc, .noOverflow1
    dec b
.noOverflow1:
    ld [hl], b

.addSprite:
    ; Add Two OAM entries to the shadow OAM
    ld hl, wShadowOAM

    ; First entry
    ld a, [wCameraOffsetY]
    ld d, a
    ld a, [wPlayerY+1]
    sub a, d
    add a, 16
    ld b, a
    ld [hl+], a
    ld a, [wCameraOffsetX]
    ld d, a
    ld a, [wPlayerX+1]
    sub a, d
    add a, 8
    ld c, a
    ld [hl+], a
    xor a
    ld [hl+], a
    ld [hl+], a

    ; Second entry
    ld a, b
    ld [hl+], a
    ld a, c
    add a, 8
    ld [hl+], a
    ld a, 2
    ld [hl+], a
    xor a
    ld [hl+], a

    ; Third entry
    ld a, b
    add a, 16
    ld [hl+], a
    ld a, c
    ld [hl+], a
    ld a, 4
    ld [hl+], a
    xor a
    ld [hl+], a

    ; Fourth entry
    ld a, b
    add a, 16
    ld [hl+], a
    ld a, c
    add a, 8
    ld [hl+], a
    ld a, 6
    ld [hl+], a
    xor a
    ld [hl+], a
    ret
