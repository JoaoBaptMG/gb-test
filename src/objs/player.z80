;
; player.z80
; Routines to control the player
;

include "gameboy.inc"
include "util/structs.inc"

; Reserve data for the player
section "wram player.z80", wram0
; player's X as a 16.8 fixed point
wPlayerX: ds 3
; player's Y as a 16.8 fixed point
wPlayerY: ds 3 
; player's speed-X as an 8.8 fixed point
wPlayerSpdX: ds 2
; player's speed-Y as an 8.8 fixed point
wPlayerSpdY: ds 2
; player's animation frame
wPlayerAnimStep: db
; camera offset X as a 16-bit integer
wCameraOffsetX:: dw
; camera offset Y as a 16-bit integer
wCameraOffsetY:: dw

section "bank 0 player.z80", rom0
; Load's the player's character on screen
PlayerLoadData::
    ; Copy the character's graphics
    ld hl, vSpriteData
    ld de, data_sprites_player_png
    ld bc, data_sprites_player_png_end - data_sprites_player_png
    jp MemoryCopy

; Init the player's "singleton object"
PlayerInit::
    ; Initialize the player
    SetDataFixed168 wPlayerX, 11*16 + 0, 0
    SetDataFixed168 wPlayerY, 12*16 + 0, 0
    SetData8 wPlayerAnimStep, 0
    ret

; Update the player, pushing the OAM alongside it
PlayerUpdate::
    ; Zero the speed data
    SetData16 wPlayerSpdX, 0
    SetData16 wPlayerSpdY, 0

    ; Get joypad input
    ld a, [hJoypadPress]
    bit PADB_LEFT, a
    jr nz, .moveLeft
    bit PADB_RIGHT, a
    jr nz, .moveRight
    jr .moveYDirection

.moveLeft:
    ; Speed of -1
    SetDataFixed88 wPlayerSpdX, -1, 0
    jr .moveYDirection

.moveRight:
    ; Speed of 1
    SetDataFixed88 wPlayerSpdX, 1, 0
    jr .moveYDirection

.moveYDirection:
    ld a, [hJoypadPress]
    bit PADB_UP, a
    jr nz, .moveUp
    bit PADB_DOWN, a
    jr nz, .moveDown
    jr .updatePosition

.moveUp:
    SetDataFixed88 wPlayerSpdY, -1, 0
    jr .updatePosition

.moveDown:
    SetDataFixed88 wPlayerSpdY, +1, 0

.updatePosition:
    call UpdatePosition

    ; Call the collision routine
    ld hl, wPlayerX
    ld bc, 16*256 - 1
    ld de, 32*256 - 1
    call CheckMapCollision

    ; If there was no collision, continue
    bit 0, a
    jr z, .updateCameraOffset

    ; Negate X
    ld hl, wPlayerSpdX
    ld a, [hl]          ; a = wPlayerSpdX.0
    cpl                 ; a = -wPlayerSpdX.0 - 1
    inc a               ; a = -wPlayerSpdX.0
    ld [hl+], a         ; reload
    ld a, [hl]          ; a = wPlayerSpdX.1
    cpl                 ; a = -wPlayerSpdX.1 - 1
    jr c, .over0        ; only increment if not carry
    inc a
.over0:
    ld [hl], a          ; correctly negated

    ; Negate Y
    ld hl, wPlayerSpdY
    ld a, [hl]          ; a = wPlayerSpdY.1
    cpl                 ; a = -wPlayerSpdY.1 - 1
    inc a               ; a = -wPlayerSpdY.1
    ld [hl+], a         ; reload
    ld a, [hl]          ; a = wPlayerSpdY.1
    cpl                 ; a = -wPlayerSpdY.1 - 1
    jr c, .over1
    inc a
.over1:
    ld [hl], a          ; correctly negated

    ; Restore the position
    call UpdatePosition

.updateCameraOffset:
    ; Update the camera offset
    ; In the X direction
    ld hl, wPlayerX+1
    ld a, [hl+]
    ld c, a
    ld b, [hl]

    ; Check if the pos is < 72
    ld a, b
    and a
    jr nz, .xPositive
    ld a, c
    cp a, 72
    jr nc, .xPositive

    ; Clamp camera offset to 0
    xor a
    ld hl, wCameraOffsetX
    ld [hl+], a
    ld [hl], a
    jr .checkY

.xPositive:
    ; Check if the pos is > than the maximum possible
    ld hl, wMaxCameraPositionRight+1
    ld a, [hl-]
    ld d, a
    cp a, b
    jr c, .setXRight        ; jump if hmax < b
    jr nz, .setXNormal      ; here, hmax >= b, jump if hmax != b
    ld a, [hl]
    cp a, c
    jr nc, .setXNormal      ; jump if lmax >= c

    ; here, either hmax < b or (hmax = b and lmax < c)
.setXRight:
    ; Clamp camera offset to (max position - 72)
    ld a, [hl]
    sub a, 72
    ld hl, wCameraOffsetX
    ld [hl+], a
    jr nc, .noOverflow3
    dec d
.noOverflow3:
    ld [hl], d
    jr .checkY

.setXNormal:
    ; Set camera offset to (player X - 72)
    ld a, c
    sub a, 72
    ld hl, wCameraOffsetX
    ld [hl+], a
    jr nc, .noOverflow0
    dec b
.noOverflow0:
    ld [hl], b

.checkY:
    ; In the Y direction
    ld hl, wPlayerY+1
    ld a, [hl+]
    ld c, a
    ld b, [hl]

    ; Check if the pos is < 48
    ld a, b
    and a
    jr nz, .yPositive
    ld a, c
    cp a, 48
    jr nc, .yPositive

    ; Clamp camera offset to 0
    xor a
    ld hl, wCameraOffsetY
    ld [hl+], a
    ld [hl], a
    jr .addSprite

.yPositive:
    ; Check if the pos is > than the maximum possible
    ld hl, wMaxCameraPositionBottom+1
    ld a, [hl-]
    ld d, a
    cp a, b
    jr c, .setYDown         ; jump if hmax < b
    jr nz, .setYNormal      ; here, hmax >= b, jump if hmax != b
    ld a, [hl]
    cp a, c
    jr nc, .setYNormal      ; jump if lmax >= c

    ; here, either hmax < b or (hmax = b and lmax < c)
.setYDown:
    ; Clamp camera offset to (max position - 48)
    ld b, a
    ld a, [hl]
    sub a, 48
    ld hl, wCameraOffsetY
    ld [hl+], a
    jr nc, .noOverflow4
    dec d
.noOverflow4:
    ld [hl], d
    jr .addSprite

.setYNormal:
    ; Set camera offset to (player Y - 48)
    ld hl, wCameraOffsetY
    ld a, c
    sub a, 48
    ld [hl+], a
    jr nc, .noOverflow1
    dec b
.noOverflow1:
    ld [hl], b

.addSprite:
    ; Add Two OAM entries to the shadow OAM
    ld hl, wShadowOAM

    ; First entry
    ld a, [wCameraOffsetY]
    ld d, a
    ld a, [wPlayerY+1]
    sub a, d
    add a, 16
    ld b, a
    ld [hl+], a
    ld a, [wCameraOffsetX]
    ld d, a
    ld a, [wPlayerX+1]
    sub a, d
    add a, 8
    ld c, a
    ld [hl+], a
    xor a
    ld [hl+], a
    ld [hl+], a

    ; Second entry
    ld a, b
    ld [hl+], a
    ld a, c
    add a, 8
    ld [hl+], a
    ld a, 2
    ld [hl+], a
    xor a
    ld [hl+], a

    ; Third entry
    ld a, b
    add a, 16
    ld [hl+], a
    ld a, c
    ld [hl+], a
    ld a, 4
    ld [hl+], a
    xor a
    ld [hl+], a

    ; Fourth entry
    ld a, b
    add a, 16
    ld [hl+], a
    ld a, c
    add a, 8
    ld [hl+], a
    ld a, 6
    ld [hl+], a
    xor a
    ld [hl+], a

    ret

; Helper routine
UpdatePosition:
    ; Add the X-velocity to the X-position
    ld hl, wPlayerSpdX
    ld a, [hl+]
    ld b, [hl]
    ld hl, wPlayerX
    add a, [hl]
    ld [hl+], a
    ld a, [hl]
    adc a, b
    ld [hl+], a

    ; Special check for addition carry (manual 2-complement)
    ; For each of the cases: no carry & b.7 = 0 | carry & b.7 = 0  | no carry & b.7 = 1 | carry & b.7 = 1  |
    sbc a, a               ; a = 0              | a = -1           | a = 0              | a = -1           |
    rl b                   ; carry = 0          | carry = 0        | carry = 1          | carry = 1        |
    ld b, a                ; b = 0              | b = -1           | b = 0              | b = -1           |
    ld a, [hl]             ; a = [hl], b = 0    | a = [hl], b = -1 | a = [hl], b = 0    | a = [hl], b = -1 |
    sbc a, b               ; a = [hl]           | a = [hl]+1       | a = [hl]-1         | a = [hl]         |
    ld [hl], a             ; expected behavior in all cases

    ; Add the Y-velocity to the Y-position
    ld hl, wPlayerSpdY
    ld a, [hl+]
    ld b, [hl]
    ld hl, wPlayerY
    add a, [hl]
    ld [hl+], a
    ld a, [hl]
    adc a, b
    ld [hl+], a

    sbc a, a
    rl b
    ld b, a
    ld a, [hl]
    sbc a, b
    ld [hl], a
    ret