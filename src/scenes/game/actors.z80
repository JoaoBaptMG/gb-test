;
; scenes/game/game.z80
; Contains the required routines to handle the game actors
;

include "gameboy.inc"

section "bank 0 scenes/game/actors.z80", rom0

; Initializes the actor list
ActorsInit::
    xor a
    ld bc, 32
    ld hl, wActorTypes
    jp MemoryFill

; Attempts to allocate space for a new actor
; input
;    - e: the type of the actor
;    - bc: the initialization structure for it
; output
;    - a will return nonzero if a slot is not found, and zero if it is found
;    - de, hl will be scrapped
;    - bc will obey whatever convention the initialization routine does,
;      but it should point *after* the initialization structure
;
ActorNew::
    ; First, try to find an empty slot
    ld hl, wActorTypes
.findLoop:
    ld a, [hl+]         ; Check if that slot is empty
    and a               ; If it is, continue
    jr z, .foundSlot
    bit 5, l            ; If all slots were full, return early
    ret nz
    jr .findLoop
.foundSlot:
    ; We need to call the init function for the actor
    ; Find the address of the allocated region
    dec l
    ld h, HIGH(wActorTypes)
    ld [hl], e                  ; Store the actor type
    ld h, 0
    add hl, hl          ; The slot of the address * 32
    add hl, hl
    add hl, hl
    add hl, hl
    add hl, hl
    ld a, HIGH(wActorBaseMemory)
    add a, h
    ld h, a             ; Now hl = wActorBaseMemory + slot * 32

    ; Load the subroutine table
    ld d, HIGH(ActorTypeTable)
    ld a, [de]          ; The subroutine's bank
    ld [rROMB0], a
    inc d
    inc d
    inc d               ; Go to the init routine's address
    ; Lack of registers, unfortunately
    push hl
    ld a, [de]          ; The init routine's low byte
    ld l, a
    inc d
    ld a, [de]          ; The init routine's high byte
    ld d, a             ; Load the init routine's address
    ld e, l
    pop hl
    ; Calling convention for the init routine
    ; - bc: the initialization struct
    ; - hl: the allocated region for the actor
    ; the init routine should point bc right after the initialization struct
    call DynamicDE
    xor a
    ret

; Load actors from map
; input
;   bc: pointing to the first actor data, loaded as
;       (type) then initialization data specific for that object
ActorsLoadFromMap::
    ld a, [bc]          ; Get the type from the actor
    and a               ; If it's zero, return
    ret z
    inc bc              ; Make bc point properly to the structure
    ld e, a             ; Transfer the type to the correct register
    call ActorNew
    and a               ; If there aren't available slots anymore, bail out
    ret nz              ; Lack of slots is represented as a != 0
    jr ActorsLoadFromMap

; Load graphics for types declared in map
; input
;   hl: pointing to the first declared type
; output
;   bc: pointing to the end of the declared types
ActorsLoadGraphicsTypes::
    ld b, h
    ld c, l
    ld hl, vActorTypeSlots
.actorLoadGraphicsLoop:
    ld a, [bc]          ; Get the declared type
    inc bc
    and a               ; Zero marks the end of the type list
    ret z
    ld d, HIGH(wTypeGraphics)   ; Assign the found ID to the correct pointer
    ld e, a

    ld a, l             ; Obtain the character ID (which is the address / 16)
    xor a, h            ; a = (l ^ h)
    and $0f             ; upper: 0, lower: l ^ h 
    xor a, h            ; upper: h, lower, l
    swap a              ; correctly calculated tile ID
    ld [de], a          ; store it to the pointer value

    push hl             ; Push the VRAM address
    ; Get the graphics address (must be bank 0)
    ld h, HIGH(ActorTypeGraphicsTable) >> 1
    ld l, e             ; Load the type to the right place
    add hl, hl          ; times 2

    ; Load the address
    ld a, [hl+]
    ld d, [hl]
    ld e, a
    pop hl

    push bc             ; Push the structure pointer
.eachTypeLoadGraphicsLoop:
    ; Load the size
    ld a, [de]          ; Check the size
    and a               ; If it's zero, bail out
    jr z, .eachTypeLoadGraphicsLoopEnd

    ld c, a             ; Load in the right register
    inc de
    ld a, [de]          ; Load the bank
    ld [rROMB0], a
    inc de
    ld a, [de]          ; Low address
    ld b, a
    inc de
    ld a, [de]          ; High address
    push de             ; Push the graphics table pointer
    ld e, b             ; Put the address in the right place
    ld d, a
    ld b, 0             ; Re-stash 0
    call MemoryCopy     ; Copy to the VRAM - hl will finish pointing to the next address
    pop de              ; Pop the graphics table pointer
    inc de
    jr .eachTypeLoadGraphicsLoop

.eachTypeLoadGraphicsLoopEnd:
    pop bc              ; Restore the structure pointer
    jr .actorLoadGraphicsLoop

; Update all the actors according to the list
ActorsUpdate::
    ; Loop for each actor and call their update function
    ld bc, wActorTypes
    ld d, HIGH(ActorTypeTable)
    ld hl, wActorBaseMemory

.actorLoop:
    ld a, [bc]      ; Pick the actor type
    and a           ; If it's empty, bail out
    jr z, .skipActor

    ld e, a         ; Load the table
    ld a, [de]      ; The subroutine's bank
    ld [rROMB0], a
    push bc
    inc d
    ld a, [de]      ; The subroutine's low addres
    ld c, a
    inc d
    ld a, [de]      ; The subroutine's high address
    ld b, a
    push hl         ; Push HL
    ; Calling convention for the update function:
    ;   hl - address of allocated region for that actor
    call DynamicBC  ; Call from BC
    pop hl          ; Restore everything
    pop bc
    ld d, HIGH(ActorTypeTable)  ; Reload the actor table

.skipActor:
    ld a, l         ; Increase the actor's data pointer
    add a, 32
    ld l, a
    jr nc, .noOverflow18
    inc h
.noOverflow18:
    inc c           ; Check if we ended all the actors
    bit 5, c
    jr z, .actorLoop
    ret

section "wram scenes/game/actors.z80", wram0, align[8]
; The actor types and the region allocated to them
wActorBaseMemory: ds 32*32
wActorTypes: ds 32
